// Code generated by musgen. DO NOT EDIT.

package entry

import (
	"github.com/momentum-xyz/ubercontroller/pkg/cmath"
	"github.com/ymz-ncnk/muserrs"
)

// MarshalMUS fills buf with the MUS encoding of v.
func (v ActivityData) MarshalMUS(buf []byte) int {
	i := 0
	if v.Position == nil {
		buf[i] = 0
		i++
	} else {
		buf[i] = 1
		i++
		{
			si := (*v.Position).MarshalMUS(buf[i:])
			i += si
		}
	}
	if v.Description == nil {
		buf[i] = 0
		i++
	} else {
		buf[i] = 1
		i++
		{
			length := len((*v.Description))
			{
				uv := uint64(length)
				if length < 0 {
					uv = ^(uv << 1)
				} else {
					uv = uv << 1
				}
				{
					for uv >= 0x80 {
						buf[i] = byte(uv) | 0x80
						uv >>= 7
						i++
					}
					buf[i] = byte(uv)
					i++
				}
			}
			if len(buf[i:]) < length {
				panic(muserrs.ErrSmallBuf)
			}
			i += copy(buf[i:], (*v.Description))
		}
	}
	if v.Hash == nil {
		buf[i] = 0
		i++
	} else {
		buf[i] = 1
		i++
		{
			length := len((*v.Hash))
			{
				uv := uint64(length)
				if length < 0 {
					uv = ^(uv << 1)
				} else {
					uv = uv << 1
				}
				{
					for uv >= 0x80 {
						buf[i] = byte(uv) | 0x80
						uv >>= 7
						i++
					}
					buf[i] = byte(uv)
					i++
				}
			}
			if len(buf[i:]) < length {
				panic(muserrs.ErrSmallBuf)
			}
			i += copy(buf[i:], (*v.Hash))
		}
	}
	return i
}

// UnmarshalMUS parses the MUS-encoded buf, and sets the result to *v.
func (v *ActivityData) UnmarshalMUS(buf []byte) (int, error) {
	i := 0
	var err error
	v.Position = new(cmath.Vec3)
	if buf[i] == 0 {
		i++
		v.Position = nil
	} else if buf[i] != 1 {
		i++
		return i, muserrs.ErrWrongByte
	} else {
		i++
		{
			var sv cmath.Vec3
			si := 0
			si, err = sv.UnmarshalMUS(buf[i:])
			if err == nil {
				(*v.Position) = sv
				i += si
			}
		}
	}
	if err != nil {
		return i, muserrs.NewFieldError("Position", err)
	}
	v.Description = new(string)
	if buf[i] == 0 {
		i++
		v.Description = nil
	} else if buf[i] != 1 {
		i++
		return i, muserrs.ErrWrongByte
	} else {
		i++
		{
			var length int
			{
				var uv uint64
				{
					if i > len(buf)-1 {
						return i, muserrs.ErrSmallBuf
					}
					shift := 0
					done := false
					for l, b := range buf[i:] {
						if l == 9 && b > 1 {
							return i, muserrs.ErrOverflow
						}
						if b < 0x80 {
							uv = uv | uint64(b)<<shift
							done = true
							i += l + 1
							break
						}
						uv = uv | uint64(b&0x7F)<<shift
						shift += 7
					}
					if !done {
						return i, muserrs.ErrSmallBuf
					}
				}
				if uv&1 == 1 {
					uv = ^(uv >> 1)
				} else {
					uv = uv >> 1
				}
				length = int(uv)
			}
			if length < 0 {
				return i, muserrs.ErrNegativeLength
			}
			if len(buf) < i+length {
				return i, muserrs.ErrSmallBuf
			}
			(*v.Description) = string(buf[i : i+length])
			i += length
		}
	}
	if err != nil {
		return i, muserrs.NewFieldError("Description", err)
	}
	v.Hash = new(string)
	if buf[i] == 0 {
		i++
		v.Hash = nil
	} else if buf[i] != 1 {
		i++
		return i, muserrs.ErrWrongByte
	} else {
		i++
		{
			var length int
			{
				var uv uint64
				{
					if i > len(buf)-1 {
						return i, muserrs.ErrSmallBuf
					}
					shift := 0
					done := false
					for l, b := range buf[i:] {
						if l == 9 && b > 1 {
							return i, muserrs.ErrOverflow
						}
						if b < 0x80 {
							uv = uv | uint64(b)<<shift
							done = true
							i += l + 1
							break
						}
						uv = uv | uint64(b&0x7F)<<shift
						shift += 7
					}
					if !done {
						return i, muserrs.ErrSmallBuf
					}
				}
				if uv&1 == 1 {
					uv = ^(uv >> 1)
				} else {
					uv = uv >> 1
				}
				length = int(uv)
			}
			if length < 0 {
				return i, muserrs.ErrNegativeLength
			}
			if len(buf) < i+length {
				return i, muserrs.ErrSmallBuf
			}
			(*v.Hash) = string(buf[i : i+length])
			i += length
		}
	}
	if err != nil {
		return i, muserrs.NewFieldError("Hash", err)
	}
	return i, err
}

// SizeMUS returns the size of the MUS-encoded v.
func (v ActivityData) SizeMUS() int {
	size := 0
	size++
	if v.Position != nil {
		{
			ss := (*v.Position).SizeMUS()
			size += ss
		}
	}
	size++
	if v.Description != nil {
		{
			length := len((*v.Description))
			{
				uv := uint64(length<<1) ^ uint64(length>>63)
				{
					for uv >= 0x80 {
						uv >>= 7
						size++
					}
					size++
				}
			}
			size += len((*v.Description))
		}
	}
	size++
	if v.Hash != nil {
		{
			length := len((*v.Hash))
			{
				uv := uint64(length<<1) ^ uint64(length>>63)
				{
					for uv >= 0x80 {
						uv >>= 7
						size++
					}
					size++
				}
			}
			size += len((*v.Hash))
		}
	}
	return size
}
